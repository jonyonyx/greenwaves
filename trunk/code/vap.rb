require 'const'
require 'dogs_threshold'

class CodePrinter
  def initialize 
    @fmt_num = "S%03d: %s"
    @fmt_nonum = "#{' '*6}%s"
    @line_number = 0
    @lines = []
  end
  def add line, print_line_number = true
    @lines << if print_line_number
      @line_number += 1 
      format(@fmt_num,@line_number,line)
    else
      format(@fmt_nonum,line)
    end
  end
  # adds a line verbatim
  def add_verb line
    @lines << line
  end
  def to_s
    @lines.join("\n")
  end
  def write filepath
    File.open(filepath, 'w') { |f|  f << to_s}
    puts "Wrote #{@lines.length} lines to '#{filepath}'"
  end
end

def gen_master(area,dn,ds,cnt_dets,occ_dets)

  cp = CodePrinter.new
  
  cp.add_verb "/* This program was automatically generated by #{$0} on #{Time.now} */"
    
  cp.add_verb "PROGRAM DOGS_MASTER ; /* #{area} */"
  cp.add_verb "CONST 
        BASE_CYCLE_TIME = #{BASE_CYCLE_TIME},
        DN = #{dn},
        DS = #{ds},
        SMOOTHING_FACTOR = 0.5,
        DOGS_LEVEL_GREEN = #{DOGS_LEVEL_GREEN},
        ENABLE_CNT = 32,
        DISABLE_CNT = 13,
        ENABLE_OCC = 45,
        DISABLE_OCC = 13,
        DOGS_FORCE_DISABLE = 0;
  "

  # Count (intensity) bounds are estimated for a counting period of BASE_CYCLE_TIME seconds
  # Occupied rate- (percentages) and count-bounds are taken from the DOGS material
  cnt_bounds = {'UPPER' => [14, 23, 32, 41, 50, 60, 69, 78], 'LOWER' => [13, 21, 29, 37, 45, 53, 61, 69]}
  occ_bounds = {'UPPER' => [11, 29, 45, 58, 70, 80, 92, 96], 'LOWER' => [8, 17, 35, 51, 65, 74, 86, 94]}
  
  cp.add_verb "/* Expressions */
    cycle_sec := T;
    cycle_sec_plus1 := cycle_sec + 1;
    CURRENT_CYCLE_TIME := BASE_CYCLE_TIME + DOGS_LEVEL_GREEN * DOGS_LEVEL;
  "
  
  cp.add "IF NOT cycle_sec THEN /* Perform initialization */"
  cp.add "  DN_CNT := 0; DS_CNT := 0; /* Keeps Vissim from nagging */"
  cp.add "  SetT(1); TRACE(ALL); /* Start the clock and tracing */"
  cp.add "  GOTO PROG_ENDE", false
  cp.add "END;", false
  
  cp.add "Marker_put(1,DOGS_LEVEL); Marker_put(2,cycle_sec);"
  cp.add "IF cycle_sec < CURRENT_CYCLE_TIME THEN"
  cp.add "  SetT(cycle_sec_plus1);"
  cp.add "  GOTO PROG_ENDE;", false
  cp.add "END;", false
  
  # Below here we actually reached cycle_sec = current cycle time
  cp.add_verb "/* When DOGS_LEVEL > 0 the counting period is extended along with the green time 
                  and the counts from the detections must be corrected before comparing to the cnt threshold values */"
  cp.add "DOGS_CORRECTION_FACTOR := BASE_CYCLE_TIME / CURRENT_CYCLE_TIME;"
  cp.add "DN_CNT := DOGS_CORRECTION_FACTOR * (DN_CNT + SMOOTHING_FACTOR * (Rear_ends(DN) - DN_CNT)); "
  cp.add "DS_CNT := DOGS_CORRECTION_FACTOR * (DS_CNT + SMOOTHING_FACTOR * (Rear_ends(DS) - DS_CNT));"    
  cp.add "DN_OCC := Occup_rate(DN) * 100; /* Occupied rate percentage */"    
  cp.add "DS_OCC := Occup_rate(DS) * 100;"
  cp.add_verb "/* Measuring on detectors, which are used to determine current dogs level */"
  for occ_det in occ_dets
    cp.add "D#{occ_det}_OCC := Occup_rate(#{occ_det}) * 100;"
  end
  for cnt_det in cnt_dets
    cp.add "D#{cnt_det}_CNT := Rear_ends(#{cnt_det});"
    cp.add "Clear_rear_ends(#{cnt_det});"
  end
  unless cnt_dets.include? dn
    cp.add "Clear_rear_ends(DN);"
  end
  unless cnt_dets.include? ds
    cp.add "Clear_rear_ends(DS);"
  end
  cp.add_verb "/* Enable dogs if north or south bounds are reached. If dogs is enabled but we are below enable-bounds, keep dogs enabled until the lower threshold is reached */"
  cp.add "DOGS_ENABLED := ((DN_CNT > ENABLE_CNT) OR (DS_CNT > ENABLE_CNT) AND (DN_OCC > ENABLE_OCC) OR (DS_OCC > ENABLE_OCC)) OR DOGS_ENABLED AND ((DN_CNT > DISABLE_CNT) OR (DS_CNT > DISABLE_CNT) AND (DN_OCC > DISABLE_OCC) OR (DS_OCC > DISABLE_OCC));"
  cp.add "IF DOGS_FORCE_DISABLE OR NOT DOGS_ENABLED THEN"
  cp.add "   DOGS_LEVEL := 0;"
  cp.add "ELSE", false 
  for level in (0...DOGS_LEVELS)
    cp.add "  IF DOGS_LEVEL = #{level} THEN"
    cp.add "     IF #{occ_dets.map{|det| "(D#{det}_OCC > #{occ_bounds['UPPER'][level]})"}.join(' OR ')} OR #{cnt_dets.map{|det| "(D#{det}_CNT > #{cnt_bounds['UPPER'][level]})"}.join(' OR ')} THEN"
    cp.add "         DOGS_LEVEL := #{level+1};"
    cp.add "     END;", false
    if level > 0
      cp.add "     IF #{occ_dets.map{|det| "(D#{det}_OCC < #{occ_bounds['LOWER'][level]})"}.join(' AND ')} AND #{cnt_dets.map{|det| "(D#{det}_CNT < #{cnt_bounds['LOWER'][level]})"}.join(' AND ')} THEN"
      cp.add "         DOGS_LEVEL := #{level-1};"
      cp.add "     END;", false
    end
    cp.add "  GOTO FINAL_STATEMENTS;", false
    cp.add "  END;", false
  end
  cp.add "END;", false
  cp.add_verb "FINAL_STATEMENTS:   SetT(1)"
  cp.add_verb 'PROG_ENDE:    .'

  cp.write "#{Vissim_dir}\DOGS.vap"
end

P_rows = exec_query "SELECT 
        PLAN.Intersection, PLAN.PROGRAM,
        NAME,
        NUMBER, 
        [DOGS Priority] As PRIORITY,
        80 As CYCLE_TIME,
        OFFSET,
        [Red End] As RED_END, 
        [Green End] As GREEN_END, 
        [Red-Amber] As TRED_AMBER, 
        Amber As TAMBER
       FROM [plans$] As PLAN
       INNER JOIN [offsets$] As OFFSET 
        ON PLAN.Intersection = OFFSET.Intersection AND PLAN.Program = OFFSET.Program"

scs = []

sc = nil
for row in P_rows
  isname = row['Intersection']
  isnum = row['Number']
  prog = row['PROGRAM']
  if not sc or not sc.name == isname or not sc.program == prog
    sc = SignalController.new(isnum, 
      'NAME' => isname, 
      'PROGRAM' => prog,
      'CYCLE_TIME' => row['CYCLE_TIME'],
      'OFFSET' => row['OFFSET'])
    scs << sc
  end
  
  sc.add SignalGroup.new(row['NUMBER'].to_i,row)
end
def gen_vap sc  
  cp = CodePrinter.new
  
  cp.add_verb "/* This program was automatically generated by #{$0} on #{Time.now} */"
  
  name = "#{sc.name.downcase.gsub(' ','_')}"
  cp.add_verb "PROGRAM #{name}; /* #{sc.program} */"
  cp.add_verb ''
  
  stages = sc.stages
  uniq_stages = stages.uniq.find_all{|s| s.is?(Stage)}
  # prepare the split of DOGS extra time between major and minor stages
  minor_stages = uniq_stages.find_all{|s| s.priority == MINOR}
    
  minor_fact = 2 * minor_stages.length
  major_fact = DOGS_TIME - minor_fact
  
  cp.add_verb "CONST"
  # calculate stage lengths
  for stage in uniq_stages
    cp.add_verb "\tSTAGE#{stage}_TIME = #{stages.find_all{|s| s == stage}.length},"
  end
  cp.add_verb "\tBASE_CYCLE_TIME = #{sc.cycle_time},\n\tOFFSET = #{sc.offset};"
  cp.add_verb ''
  # calculate stage end times based on stage lengths
  for i in (0...uniq_stages.length)
    prev, cur = uniq_stages[i-1], uniq_stages[i]
    cp.add_verb "stage#{cur}_end := STAGE#{cur}_TIME" + 
      (cur.priority == NONE ? '' : " + #{cur.priority == MAJOR ? major_fact : minor_fact} * DOGS_LEVEL") +
      (cur == uniq_stages.first ? ';' : " + Interstage_length(#{prev},#{cur}) + stage#{prev}_end;")
  end
  
  cp.add_verb ''
  
  # dogs master sync and local timing calculations
  cp.add 'DOGS_LEVEL := Marker_get(1); TIME := Marker_get(2);'
  cp.add 'IF NOT SYNC THEN'
  cp.add '   IF TIME = (OFFSET - 1) THEN'
  cp.add '      SYNC := 1; TRACE(ALL)'
  cp.add '   END;', false
  cp.add '   GOTO PROG_ENDE', false
  cp.add 'END;', false
  cp.add "C := BASE_CYCLE_TIME + #{DOGS_TIME} * DOGS_LEVEL;"
  cp.add "IF TIME >= OFFSET THEN /* Poor man's modulos (VAP version 4) */"
  cp.add '   t_loc := TIME - OFFSET + 1'
  cp.add 'ELSE', false
  cp.add '   t_loc := TIME - OFFSET + C + 1'
  cp.add 'END;', false
  cp.add 'SetT(t_loc);'
  
  # checks for interstage runs
  for i in (0...uniq_stages.length)
    cur, nxt = uniq_stages[i], uniq_stages[(i+1) % uniq_stages.length]
    # check that from-stage is running - may not be due to dogs level change!
    cp.add "IF Stage_active(#{cur}) THEN" 
    cp.add "   IF T = stage#{cur}_end THEN"
    cp.add "      Is(#{cur},#{nxt})"
    cp.add "   END", false
    cp.add "END#{i < uniq_stages.length-1 ? ';' : ''}",false
  end
  cp.add_verb 'PROG_ENDE:    .'
  
  cp.write("#{Vissim_dir}\\#{name}.vap")
end

def gen_pua sc
  cp = CodePrinter.new
  cp.add_verb '$SIGNAL_GROUPS'
  cp.add_verb '$'
  for grp in sc.groups.values.sort{|g1,g2| g1.number <=> g2.number}
    cp.add_verb "#{grp.name}\t#{grp.number}"
  end
  
  cp.add_verb ''  
  cp.add_verb '$STAGES'
  cp.add_verb '$'
  
  stages = sc.stages
  uniq_stages = stages.uniq.find_all{|s| s.is?(Stage)}
  
  for stage in uniq_stages
    cp.add_verb "Stage_#{stage.number}\t#{stage.groups.map{|g|g.name}.join(' ')}"
    cp.add_verb "red\t#{(sc.groups.values - stage.groups).map{|g|g.name}.join(' ')}"
  end
  
  cp.add_verb ''  
  cp.add_verb '$STARTING_STAGE'
  cp.add_verb '$'
  cp.add_verb 'Stage_1'
  cp.add_verb ''  
  
  isnum = 0
  for t in (2..sc.cycle_time)
    next unless stages[t-1] != stages[t] and stages[t-1].is?(Stage)
    isnum += 1
    cp.add_verb "$INTERSTAGE#{isnum}"
    
    # find the length of the interstage
    islen = 0
    fromstage = stages[t-1]
    if stages[t].is?(Stage)
      # interstage happens from one cycle second to the next
      tostage = stages[t]
    else
      # this is an extended interstage
      islen += 1 while stages[t+islen] == stages[t]
      tostage = stages[t+islen+1]
    end
    
    cp.add_verb "Length [s]: #{islen}"
    cp.add_verb "From Stage: #{fromstage}"
    cp.add_verb "To Stage: #{tostage ? tostage : uniq_stages.first}" #wrap around cycle
    cp.add_verb "$\tredend\tgrend"
    
    # capture all changes in this interstage
    for it in (0..islen)
      for grp in sc.groups.values
        # compare the colors of the previous and
        # current heads        
        
        tp = t + it
        case [grp.color(tp),grp.color(tp+1)]
        when [AMBER,AMBER]
          # this is the 2nd amber second, red ended 2 secs ago
          cp.add_verb "#{grp.name}\t#{it - 1}\t127"
        when [RED,GREEN]
          # direct change from red to green
          cp.add_verb "#{grp.name}\t#{it}\t127"
        when [GREEN,RED],[GREEN,YELLOW]
          # change from green to yellow or          
          # this light became red immediately
          cp.add_verb "#{grp.name}\t-127\t#{it}"
        end
      end
    end
    
    cp.add_verb ''  
  end  
  
  cp.add_verb '$END'
  
  cp.write("#{Vissim_dir}\\#{sc.name.downcase.gsub(' ','_')}.pua")
end

gen_master 'Herlev', 3,14,[3,14],[3,4,13,14]

exit(0)

for sc in scs
  gen_vap sc
  gen_pua sc
  puts "Generated VAP and PUA files for #{sc.name} #{sc.program}"
end