require 'const'
require 'dbi'

Plans_file = "../data/data.xls"
CS = "DBI:ADO:Provider=Microsoft.Jet.OLEDB.4.0;Data Source=#{Plans_file};Extended Properties=\"Excel 8.0;HDR=Yes;IMEX=1\";"

DBI.connect(CS) do |dbh|  
  P_rows = dbh.select_all "SELECT 
        PLAN.Intersection, PLAN.PROGRAM,
        Groupname As NAME, 
        [DOGS Priority] As PRIORITY,
        80 As CYCLE_TIME,
        OFFSET,
        [Red End] As RED_END, 
        [Green End] As GREEN_END, 
        [Red-Amber] As TRED_AMBER, 
        Amber As TAMBER
       FROM [plans$] As PLAN
       INNER JOIN [offsets$] As OFFSET 
        ON PLAN.Intersection = OFFSET.Intersection AND PLAN.Program = OFFSET.Program"
end

scs = []

sc = nil
for row in P_rows
  isname = row['Intersection']
  isnum = row['Number']
  prog = row['PROGRAM']
  if not sc or not sc.name == isname or not sc.program == prog
    grpnum = 1
    sc = SignalController.new(isnum, 
      'NAME' => isname, 
      'PROGRAM' => prog,
      'CYCLE_TIME' => row['CYCLE_TIME'],
      'OFFSET' => row['OFFSET'])
    scs << sc
  end
  
  sc.add SignalGroup.new(grpnum,row)
  grpnum += 1
end
class CodePrinter
  def initialize 
    @fmt_num = "S%03d: %s"
    @fmt_nonum = "#{' '*6}%s"
    @line_number = 0
    @lines = []
  end
  def add line, print_line_number = true
    @lines << if print_line_number
      @line_number += 1 
      format(@fmt_num,@line_number,line)
    else
      format(@fmt_nonum,line)
    end
  end
  # adds a line verbatim
  def add_verb line
    @lines << line
  end
  def to_s
    @lines.join("\n")
  end
  def write filepath
    File.open(filepath, 'w') { |f|  f << to_s}
  end
end
def gen_vap sc  
  cp = CodePrinter.new
  
  cp.add_verb "/* This program was automatically generated by #{$0} on #{Time.now} */"
  
  name = "#{sc.name.downcase.gsub(' ','_')}"
  cp.add_verb "PROGRAM #{name}; /* #{sc.program} */"
  cp.add_verb ''
  
  stages = sc.stages
  uniq_stages = stages.uniq.find_all{|s| s.is?(Stage)}
  # prepare the split of DOGS extra time between major and minor stages
  minor_stages = uniq_stages.find_all{|s| s.priority == MINOR}
    
  minor_fact = 2 * minor_stages.length
  major_fact = DOGS_TIME - minor_fact
  
  cp.add_verb "CONST"
  # calculate stage lengths
  for stage in uniq_stages
    cp.add_verb "   STAGE#{stage}_TIME = #{stages.find_all{|s| s == stage}.length},"
  end
  cp.add_verb "   BASE_CYCLE_TIME = #{sc.cycle_time},"
  cp.add_verb "   OFFSET = #{sc.offset};"
  cp.add_verb ''
  # calculate stage end times based on stage lengths
  for i in (0...uniq_stages.length)
    prev, cur = uniq_stages[i-1], uniq_stages[i]
    cp.add_verb "stage#{cur}_end := STAGE#{cur}_TIME" + 
      (cur.priority == NONE ? '' : " + #{cur.priority == MAJOR ? major_fact : minor_fact} * DOGS_LEVEL") +
      (cur == uniq_stages.first ? ';' : " + Interstage_length(#{prev},#{cur}) + stage#{prev}_end;")
  end
  
  cp.add_verb ''
  
  # dogs master sync and local timing calculations
  cp.add 'DOGS_LEVEL := Marker_get(1); TIME := Marker_get(2);'
  cp.add 'IF NOT SYNC THEN'
  cp.add '   IF TIME = (OFFSET - 1) THEN'
  cp.add '      SYNC := 1; TRACE(ALL)'
  cp.add '   END;', false
  cp.add '   GOTO PROG_ENDE', false
  cp.add 'END;', false
  cp.add "C := BASE_CYCLE_TIME + #{DOGS_TIME} * DOGS_LEVEL;"
  cp.add 'IF TIME >= OFFSET THEN'
  cp.add '   t_loc := TIME - OFFSET + 1'
  cp.add 'ELSE', false
  cp.add '   t_loc := TIME - OFFSET + C + 1'
  cp.add 'END;', false
  cp.add 'SetT(t_loc);'
  
  # checks for interstage runs
  for i in (0...uniq_stages.length)
    cur, nxt = uniq_stages[i], uniq_stages[(i+1) % uniq_stages.length]
    cp.add "IF T = stage#{cur}_end THEN"
    cp.add "   Is(#{cur},#{nxt})"
    cp.add 'END;',false
  end
  cp.add_verb 'PROG_ENDE:    .'
  
  cp.write("#{Vissim_dir}\\#{name}.vap")
end

def gen_pua sc
  cp = CodePrinter.new
  cp.add_verb '$SIGNAL_GROUPS'
  cp.add_verb '$'
  for grp in sc.groups.values.sort{|g1,g2| g1.number <=> g2.number}
    cp.add_verb "#{grp.name}\t#{grp.number}"
  end
  
  cp.add_verb ''  
  cp.add_verb '$STAGES'
  cp.add_verb '$'
  
  stages = sc.stages
  uniq_stages = stages.uniq.find_all{|s| s.is?(Stage)}
  
  for stage in uniq_stages
    cp.add_verb "Stage_#{stage.number}\t#{stage.groups.map{|g|g.name}.join(' ')}"
    cp.add_verb "red\t#{(sc.groups.values - stage.groups).map{|g|g.name}.join(' ')}"
  end
  
  cp.add_verb ''  
  cp.add_verb '$STARTING_STAGE'
  cp.add_verb '$'
  cp.add_verb 'Stage_1'
  cp.add_verb ''  
  
  isnum = 0
  for t in (2..sc.cycle_time)
    next unless stages[t-1] != stages[t] and stages[t-1].is?(Stage)
    isnum += 1
    cp.add_verb "$INTERSTAGE#{isnum}"
    
    # find the length of the interstage
    islen = 0
    fromstage = stages[t-1]
    if stages[t].is?(Stage)
      # interstage happens from one cycle second to the next
      tostage = stages[t]
    else
      # this is an extended interstage
      islen += 1 while stages[t+islen] == stages[t]
      tostage = stages[t+islen+1]
    end
    
    cp.add_verb "Length [s]: #{islen}"
    cp.add_verb "From Stage: #{fromstage}"
    cp.add_verb "To Stage: #{tostage ? tostage : uniq_stages.first}" #wrap around cycle
    cp.add_verb "$\tredend\tgrend"
    
    # capture all changes in this interstage
    for it in (0..islen)
      for grp in sc.groups.values
        # compare the colors of the previous and
        # current heads        
        
        tp = t + it
        case [grp.color(tp),grp.color(tp+1)]
        when [AMBER,AMBER]
          # this is the 2nd amber second, red ended 2 secs ago
          cp.add_verb "#{grp.name}\t#{it - 1}\t127"
        when [RED,GREEN]
          # direct change from red to green
          cp.add_verb "#{grp.name}\t#{it}\t127"
        when [GREEN,RED],[GREEN,YELLOW]
          # change from green to yellow or          
          # this light became red immediately
          cp.add_verb "#{grp.name}\t-127\t#{it}"
        end
      end
    end
    
    cp.add_verb ''  
  end  
  
  cp.add_verb '$END'
  
  cp.write("#{Vissim_dir}\\#{sc.name.downcase.gsub(' ','_')}.pua")
end

for sc in scs[1..1]
  #gen_vap sc
  gen_pua sc
  puts "Processed #{sc.name} #{sc.program}"
end